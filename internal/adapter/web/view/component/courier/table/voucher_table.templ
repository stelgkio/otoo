package views

import (
	"fmt"
	c "github.com/stelgkio/otoo/internal/adapter/web/view/component/courier/modal"
	p "github.com/stelgkio/otoo/internal/adapter/web/view/component/pagination"
	"github.com/stelgkio/otoo/internal/core/domain"
)

templ VoucherTable(projectId string, extensions []*domain.ProjectExtension) {
	<div id="dashboard-voucher">
		<div id="dashboard-voucher-table" x-data={ fmt.Sprintf("voucherTable('%s')", projectId) } x-init="init()">
			<div class="px-6 px-lg-7 pt-1 border-bottom">
				<ul class="nav nav-tabs nav-tabs-flush gap-8 overflow-x border-0 mt-4">
					<li class="nav-item">
						<a
							data-i18n="voucher-table-new-order"
							href="#"
							:class="{'nav-link': true, 'active': currentTab === 'new'}"
							@click.prevent="selectTab('new')"
						>New</a>
					</li>
					<li class="nav-item">
						<a
							data-i18n="voucher-table-processing-orders"
							href="#"
							:class="{'nav-link': true, 'active': currentTab === 'processing'}"
							@click.prevent="selectTab('processing')"
						>Processing</a>
					</li>
					<li class="nav-item">
						<a
							data-i18n="voucher-table-completed-orders"
							href="#"
							:class="{'nav-link': true, 'active': currentTab === 'completed'}"
							@click.prevent="selectTab('completed')"
						>Completed</a>
					</li>
					<li class="nav-item">
						<a
							data-i18n="voucher-table-cancelled-orders"
							href="#"
							:class="{'nav-link': true, 'active': currentTab === 'cancelled'}"
							@click.prevent="selectTab('cancelled')"
						>Canceled</a>
					</li>
					<li class="nav-item">
						<a
							data-i18n="voucher-table-all-orders"
							href="#"
							:class="{'nav-link': true, 'active': currentTab === 'all'}"
							@click.prevent="selectTab('all')"
						>All</a>
					</li>
				</ul>
			</div>
			<div class="d-flex gap-2 scrollable-x py-3 px-7 border-bottom">
				<div class="align-items-center ms-auto text-sm text-muted text-primary-hover fw-semibold d-none d-md-flex" role="button">
					<div class="hstack gap-2 ms-auto">
						<button type="button" class="btn btn-sm btn-neutral d-none d-lg-inline-flex">
							<i class="bi bi-arrow-90deg-right me-2"></i><span data-i18n="voucher-table-export-voucher-button">Export</span>
						</button>
						<button type="button" class="btn btn-sm btn-primary d-none d-lg-inline-flex">
							<i class="bi bi-plus-lg me-2"></i><span data-i18n="voucher-table-new-voucher-button">New Voucher</span>
						</button>
					</div>
				</div>
			</div>
			<div class="table-responsive">
				<table class="table table-hover table-striped table-sm table-nowrap">
					<thead>
						<tr>
							<th>
								<div class="text-base">
									<div class="form-check">
										<input
											class="form-check-input"
											type="checkbox"
											@change="selectAll()"
											x-model="selectAllCheckbox"
										/>
									</div>
								</div>
							</th>
							<template x-if="!isNewTab">
								<th @click="sortTable('Id')">
									Voucher ID
									<i :class="getSortIcon('Id')"></i>
								</th>
							</template>
							<th @click="sortTable('orderId')">
								Order ID
								<i :class="getSortIcon('orderId')"></i>
							</th>
							<th @click="sortTable('updated_at')">
								Date
								<i :class="getSortIcon('updated_at')"></i>
							</th>
							<th @click="sortTable('total_amount')">
								COD
								<i :class="getSortIcon('total_amount')"></i>
							</th>
							<th>Status</th>
							<template x-if="isPrinted">
								<th @click="sortTable('is_printed')">
									Printed
									<i :class="getSortIcon('is_printed')"></i>
								</th>
							</template>
							<th>Action</th>
						</tr>
					</thead>
					<tbody>
						<template x-if="!loading && totalItems === 0">
							<tr>
								<td colspan="8">No vouchers found.</td>
							</tr>
						</template>
						<template x-for="voucher in paginatedVouchers" :key="voucher.Id">
							<tr @click="openOffcanvas(voucher)">
								<td>
									<div class="text-base">
										<div class="form-check">
											<input
												class="form-check-input"
												type="checkbox"
												:value="voucher.Id"
												x-model="selectedVouchers"
												@click.stop
											/>
										</div>
									</div>
								</td>
								<template x-if="!isNewTab">
									<td x-text="voucher.voucherId"></td>
								</template>
								<td x-text="'#' + voucher.orderId"></td>
								<td x-text="new Date(voucher.updated_at).toLocaleString()"></td>
								<td x-text="voucher.total_amount"></td>
								<td>
									<span :class="badgeClass(voucher.status)" x-text="voucher.status"></span>
								</td>
								<template x-if="isPrinted">
									<td>
										<template x-if="voucher.is_printed">
											<span x-text="'Yes'"></span>
										</template>
										<template x-if="!voucher.is_printed">
											<span x-text="'No'"></span>
										</template>
									</td>
								</template>
								<td>
									<template x-if="voucher.status === 'new'">
										<button
											type="button"
											class="btn btn-sm btn-neutral"
											@click="$dispatch('show-offcanvas', { voucher })"
										>
											<i class="bi bi-plus-circle me-2"></i>Create Voucher
										</button>
									</template>
									<template x-if="voucher.status !== 'new'">
										<button type="button" class="btn btn-sm btn-neutral" @click.stop="downloadVoucher(voucher.Id, voucher.courier_provider)">
											<i
												class="fas fa-download ml-1"
												style="cursor: pointer;"
												title="Download Voucher"
											></i>
										</button>
									</template>
									<template x-if="voucher.status !== 'new'">
										<button type="button" class="btn btn-sm btn-neutral">
											<i class="bi bi-eye"></i>
										</button>
									</template>
								</td>
							</tr>
						</template>
						<template x-for="i in 10 - paginatedVouchers.length" :key="'empty' + i">
							<tr>
								<td colspan="8" class="py-5"></td>
							</tr>
						</template>
					</tbody>
				</table>
			</div>
			/* Start Off canvas */
			@c.CreateVoucher(extensions, projectId)
			@p.PaginationControl()
		</div>
	</div>
	<script>
function voucherTable(projectId) {
    return {
        projectID: projectId,
        currentTab: 'new',
        vouchers: [],
        selectedVouchers: [],
        selectAllCheckbox: false,
        sortKey: 'created_at',
        sortAsc: false,
        currentPage: 1,
        itemsPerPage: 10,
        totalItems: 0,
        totalPages: 0,
        loading: false,
        selectedStatus: '',
        errorMessage: '',
		isNewTab: true, 
		isPrinted: false,
     

        async init() {
            await this.fetchVouchers(this.currentPage);
        },

        async fetchVouchers(page = 1) {
            this.loading = true;
            try {
                const url = this.getUrlForTab(this.currentTab, page);
                const response = await fetch(url);
                const result = await response.json();
                if (response.ok) {
                    this.vouchers = result.data || [];
                    this.totalItems = result.meta.totalItems || 0;
                    this.currentPage = result.meta.currentPage || 1;
                    this.itemsPerPage = result.meta.itemsPerPage || 10;
                    this.totalPages = result.meta.totalPages || 0;
                } else {
                    console.error('Error fetching data:', result.message);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                this.loading = false;
            }
        },

        getUrlForTab(tab, page) {
            const baseUrl = `${window.location.origin}/voucher/table/${this.projectID}`;
            const sortDirection = this.sortAsc ? 'asc' : 'desc';
            switch (tab) {
                case 'all':
                    return `${baseUrl}/all/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'pending':
                    return `${baseUrl}/pending/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'completed':
                    return `${baseUrl}/completed/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'processing':
                    return `${baseUrl}/processing/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'cancelled':
                    return `${baseUrl}/cancelled/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
				case 'new':
                    return `${baseUrl}/new/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                default:
                    return `${baseUrl}/all/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
            }
        },

        selectTab(tab) {
			if (tab != 'new') {
				this.isNewTab = false;
				this.isPrinted = true;
			}else {
				this.isNewTab = true;
				this.isPrinted = false;
			}
            this.currentTab = tab;
            this.currentPage = 1; 
            this.fetchVouchers(this.currentPage);
        },

        selectAll() {
            this.selectedVouchers = this.selectAllCheckbox ? this.vouchers.map(voucher => voucher.Id) : [];
        },

        sortTable(key) {
            if (this.sortKey === key) {
                this.sortAsc = !this.sortAsc;
            } else {
                this.sortKey = key;
                this.sortAsc = true;
            }
            this.fetchVouchers(this.currentPage);
        },
        getSortIcon(key) {
            if (this.sortKey !== key) return '';
            return this.sortAsc ? 'bi bi-chevron-up' : 'bi bi-chevron-down';
        },

        changePage(page) {
            if (page < 1 || page > this.totalPages) return;
            this.fetchVouchers(page);
        },

		async downloadVoucher(voucherId,courier_provider) {
        
		var url = '';
		if (courier_provider == 'courier4u' ){
			url=`/voucher/courier4u/donwload/${voucherId}/${this.projectID}`;
		} else if (courier_provider == 'acs-courier') {
			url=`/voucher/acscourier/download/${voucherId}/${this.projectID}`;
		} else {
			url=`/voucher/redcourier/download/${voucherId}/${this.projectID}`;
			
		}
       	 console.log(`Downloading voucher with ID: ${voucherId}`);
		 // Assuming you have a function to fetch the data from your endpoint
			await fetch(url)
			.then(response => {
				if (response.ok) {
				return response.json(); // Assuming response has { filename, base64 }
				} else {
				throw new Error("Network response was not OK");
				}
			})
			.then(data => {
				// Extract filename and base64 content
				const { filename, base64 } = data;

				// Ensure there are no data URI prefixes
				const cleanedBase64 = base64.split(',').pop();

				// Decode base64 to binary string
				let binaryString;
				try {
				binaryString = atob(cleanedBase64);
				} catch (error) {
				console.error("Failed to decode base64 data:", error);
				return;
				}

				// Convert binary string to Uint8Array
				const byteArray = new Uint8Array(binaryString.length);
				for (let i = 0; i < binaryString.length; i++) {
				byteArray[i] = binaryString.charCodeAt(i);
				}

				// Create a Blob with 'application/pdf' MIME type
				const blob = new Blob([byteArray], { type: 'application/pdf' });

				// Create an anchor element to trigger download
				const link = document.createElement('a');
				link.href = window.URL.createObjectURL(blob);
				link.download = filename || "downloaded-file.pdf";
				link.click();

				// Clean up URL object
				window.URL.revokeObjectURL(link.href);
			})
			.catch(error => {
				console.error("There was a problem with the fetch operation:", error);
			});
         this.fetchVouchers(page);
    	},

        get paginatedVouchers() {
            return this.vouchers;
        },
		get currentPageStart() {
			return (this.currentPage - 1) * this.itemsPerPage + 1;
		},

		get currentPageEnd() {
			return Math.min(this.currentPage * this.itemsPerPage, this.totalItems);
		},
		get pageNumbers() {
			const range = 2; // Number of pages to show around the current page
			let start = Math.max(1, this.currentPage - range);
			let end = Math.min(this.totalPages, this.currentPage + range);

			// Adjust range if there are not enough pages on one side
			if (this.totalPages - end < range) {
				end = this.totalPages;
				start = Math.max(1, end - 2 * range);
			} else if (start <= range) {
				start = 1;
				end = Math.min(this.totalPages, start + 2 * range);
			}

			return Array.from({ length: end - start + 1 }, (_, i) => start + i);
		},

        badgeClass(status) {
            const baseClass = 'badge bg-body-secondary badge-custom';
            switch (status) {
                case 'pending':
                    return `${baseClass} text-info`;
				 case 'new':
                    return `${baseClass} text-primary`;	
                case 'completed':
                    return `${baseClass} text-success`;
                case 'cancelled':
                    return `${baseClass} text-danger`;
                case 'processing':
                    return `${baseClass} text-warning`;
                default:
                    return baseClass;
            }
        },

        async applyAction() {
            if (!this.selectedStatus || !this.selectedVouchers.length) {
                this.errorMessage = 'Please select a status and at least one voucher.';
                return;
            }
            this.loading = true;
            try {
                const response = await fetch('/voucher/bulk-action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        voucherIds: this.selectedVouchers,
                        status: this.selectedStatus,
                    }),
                });
                const result = await response.json();
                if (response.ok) {
                    this.selectedVouchers = [];
                    this.selectedStatus = '';
                    this.selectAllCheckbox = false;
                    this.fetchVouchers(this.currentPage);
                } else {
                    this.errorMessage = result.message;
                }
            } catch (error) {
                this.errorMessage = 'An error occurred while processing the request.';
            } finally {
                this.loading = false;
            }
        },
		
    };
}

</script>
}
