package views

import (
	"fmt"
	p "github.com/stelgkio/otoo/internal/adapter/web/view/component/pagination"
)

templ CustomerTable(projectId string) {
	<div id="dashboard-order-table" x-data={ fmt.Sprintf("customerTable('%s')", projectId) } x-init="init()">
		<div class="row align-items-center g-6 mt-0 mb-6">
			<div class="col-sm-6">
				<div class="d-flex gap-2">
					<div class="input-group input-group-sm input-group-inline w-100 w-md-50">
						<span class="input-group-text">
							<i
								class="bi bi-search me-2"
							></i>
						</span>
						<input
							type="search"
							class="form-control ps-0"
							placeholder="Search all customers"
							aria-label="Search"
						/>
					</div>
				</div>
			</div>
		</div>
		<div class="border-top">
			<div class="table-responsive">
				<table class="table table-hover table-sm table-nowrap">
					<thead>
						<tr>
							<th scope="col">Name</th>
							<th @click="sortTable('email')">
								Email
								<i :class="getSortIcon('email')"></i>
							</th>
							<th @click="sortTable('order_count')">
								Total Orders
								<i :class="getSortIcon('order_count')"></i>
							</th>
							<th scope="col">Money Spend</th>
						</tr>
					</thead>
					<tbody>
						<template x-if="!loading && totalItems === 0">
							<tr>
								<td colspan="8">No customer found.</td>
							</tr>
						</template>
						<template x-for="customer in paginatedCustomers" :key="customer.id">
							<tr>
								<td x-text="customer.name"></td>
								<td x-text="customer.email"></td>
								<td x-text="customer.totalOrders"></td>
								<td x-text="customer.totalSpent"></td>
							</tr>
						</template>
						<template x-for="i in 10 - paginatedCustomers.length" :key="'empty' + i">
							<tr>
								<td colspan="5" class="py-7"></td>
							</tr>
						</template>
					</tbody>
				</table>
			</div>
			@p.PaginationControl()
		</div>
	</div>
	<script>
function customerTable(projectId) {
    return {
		projectID: projectId,
        currentTab: 'all',
        customers: [],
        selectedcustomers: [],
        selectAllCheckbox: false,
        sortKey: 'order_count',
        sortAsc: false,
        currentPage: 1,
        itemsPerPage: 10,
        totalItems: 0,
        totalPages: 0,
        loading: false,

        async init() {
            await this.fetchcustomers(this.currentPage);
        },

        async fetchcustomers(page = 1) {
            this.loading = true;
            try {
                const url = this.getUrlForTab(this.currentTab, page);
                const response = await fetch(url);
                const result = await response.json();
                if (response.ok) {
                    this.customers = result.data || [];
                    this.totalItems = result.meta.totalItems || 0;
                    this.currentPage = result.meta.currentPage || 1;
                    this.itemsPerPage = result.meta.itemsPerPage || 10;
                    this.totalPages = result.meta.totalPages || 0;
                } else {
                    console.error('Error fetching data:', result.message);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                this.loading = false;
            }
        },

         getUrlForTab(tab, page) {
            const baseUrl = `${window.location.origin}/customer/table/${this.projectID}`;
            const sortDirection = this.sortAsc ? 'asc' : 'desc'; // Determine sort direction
            switch (tab) {
                case 'all':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'completed':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'processing':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'pending':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'cancelled':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                default:
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
            }
        },

        selectTab(tab) {
            this.currentTab = tab;
            this.currentPage = 1; // Reset to first page
            this.fetchcustomers(this.currentPage);
        },

        selectAll() {
            this.selectedcustomers = this.selectAllCheckbox ? this.customers.map(order => order.orderId) : [];
        },

      	sortTable(key) {
            if (this.sortKey === key) {
                this.sortAsc = !this.sortAsc; // Toggle sort direction if the same column is clicked
            } else {
                this.sortKey = key; // Set new sort key
                this.sortAsc = true; // Default to ascending if a new column is selected
            }
            this.fetchcustomers(this.currentPage); // Fetch sorted data
        },
		getSortIcon(key) {
            if (this.sortKey !== key) return '';
            return this.sortAsc ? 'bi bi-chevron-up' : 'bi bi-chevron-down';
        },

        changePage(page) {
            if (page < 1 || page > this.totalPages) return;
            this.fetchcustomers(page);
        },

        get paginatedCustomers() {
            return this.customers;
        },

        get currentPageStart() {
            return (this.currentPage - 1) * this.itemsPerPage + 1;
        },

        get currentPageEnd() {
            return Math.min(this.currentPage * this.itemsPerPage, this.totalItems);
        },
       	get pageNumbers() {
            const range = 2; // Number of pages to show around the current page
            let start = Math.max(1, this.currentPage - range);
            let end = Math.min(this.totalPages, this.currentPage + range);

            // Adjust range if there are not enough pages on one side
            if (this.totalPages - end < range) {
                end = this.totalPages;
                start = Math.max(1, end - 2 * range);
            } else if (start <= range) {
                start = 1;
                end = Math.min(this.totalPages, start + 2 * range);
            }
			
            return Array.from({ length: end - start + 1 }, (_, i) => start + i);
        },
		 badgeClass(status) {
				const baseClass = 'badge bg-body-secondary badge-custom'; // Add badge-custom class
				switch (status) {
					case 'pending':
						return `${baseClass} text-warning`;
					case 'completed':
						return `${baseClass} text-success`;
					case 'cancelled':
						return `${baseClass} text-danger`;
					case 'processing':
						return `${baseClass} text-warning`;
					default:
						return baseClass;
				}
		}		
    };
}
</script>
}
