package views

import (
	"fmt"
	p "github.com/stelgkio/otoo/internal/adapter/web/view/component/pagination"
)

templ ProductTable(projectId string) {
	<div id="dashboard-order-table" x-data={ fmt.Sprintf("productTable('%s')", projectId) } x-init="init()">
		<div class="row align-items-center g-6 mt-0 mb-6">
			<div class="col-sm-6">
				<div class="d-flex gap-2">
					<div class="input-group input-group-sm input-group-inline w-100 w-md-50">
						<span class="input-group-text">
							<i
								class="bi bi-search me-2"
							></i>
						</span>
						<input
							type="search"
							class="form-control ps-0"
							placeholder="Search all products"
							aria-label="Search"
						/>
					</div>
				</div>
			</div>
		</div>
		<div class="border-top">
			<div class="table-responsive">
				<table class="table table-hover table-striped table-nowrap">
					<thead>
						<tr>
							//<th scope="col">Image</th>
							<th scope="col">Product ID</th>
							<th scope="col">Name</th>
							//	<th scope="col">SKU</th>
							<th scope="col">Price</th>
							<th scope="col">Category</th>
							<th scope="col">Type</th>
							<th scope="col">Total Orders</th>
							// <th scope="col">Timestamp</th>
						</tr>
					</thead>
					<tbody>
						<template x-if="!loading && totalItems === 0">
							<tr>
								<td colspan="8">No products found.</td>
							</tr>
						</template>
						<template x-for="product in paginatedProducts" :key="product.id">
							<tr>
								//<td>
								// <template x-if="product.product_image_url">
								// 	<img
								// 		:src="product.product_image_url"
								// 		class="avatar avatar-sm rounded-circle"
								// 		alt="Product Image"
								// 	/>
								// </template>
								//</td>
								<td x-text="product.productId"></td>
								<td x-text="product.name"></td>
								//<td x-text="product.sku"></td>
								<td x-text="product.price"></td>
								<td x-text="product.category"></td>
								<td x-text="product.product_type"></td>
								<td x-text="product.total_orders"></td>
								// <td x-text="new Date(product.timestamp).toLocaleDateString()"></td>
							</tr>
						</template>
						<!-- Fill remaining rows if less than 10 -->
						<template x-for="i in 10 - paginatedProducts.length" :key="'empty' + i">
							<tr>
								<td colspan="7" class="py-7"></td>
							</tr>
						</template>
					</tbody>
				</table>
			</div>
			@p.PaginationControl()
		</div>
	</div>
	<script>
function productTable(projectId) {
    return {
		projectID: projectId,
        currentTab: 'all',
        products: [],
        selectedProducts: [],
        selectAllCheckbox: false,
        sortKey: 'timestamp',
        sortAsc: false,
        currentPage: 1,
        itemsPerPage: 10,
        totalItems: 0,
        totalPages: 0,
        loading: false,

        async init() {
            await this.fetchProducts(this.currentPage);
        },

        async fetchProducts(page = 1) {
            this.loading = true;
            try {
                const url = this.getUrlForTab(this.currentTab, page);
                const response = await fetch(url);
                const result = await response.json();
                if (response.ok) {
                    this.products = result.data || [];
                    this.totalItems = result.meta.totalItems || 0;
                    this.currentPage = result.meta.currentPage || 1;
                    this.itemsPerPage = result.meta.itemsPerPage || 10;
                    this.totalPages = result.meta.totalPages || 0;
                } else {
                    console.error('Error fetching data:', result.message);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            } finally {
                this.loading = false;
            }
        },

         getUrlForTab(tab, page) {
            const baseUrl = `http://localhost:8081/product/table/${this.projectID}`;
            const sortDirection = this.sortAsc ? 'asc' : 'desc'; // Determine sort direction
            switch (tab) {
                case 'all':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'completed':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'processing':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'pending':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                case 'cancelled':
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
                default:
                    return `${baseUrl}/${page}?sort=${this.sortKey}&direction=${sortDirection}`;
            }
        },

        selectTab(tab) {
            this.currentTab = tab;
            this.currentPage = 1; // Reset to first page
            this.fetchProducts(this.currentPage);
        },

        selectAll() {
            this.selectedProducts = this.selectAllCheckbox ? this.products.map(order => order.orderId) : [];
        },

      	sortTable(key) {
            if (this.sortKey === key) {
                this.sortAsc = !this.sortAsc; // Toggle sort direction if the same column is clicked
            } else {
                this.sortKey = key; // Set new sort key
                this.sortAsc = true; // Default to ascending if a new column is selected
            }
            this.fetchProducts(this.currentPage); // Fetch sorted data
        },
		  getSortIcon(key) {
            if (this.sortKey !== key) return '';
            return this.sortAsc ? 'bi bi-chevron-up' : 'bi bi-chevron-down';
        },

        changePage(page) {
            if (page < 1 || page > this.totalPages) return;
            this.fetchProducts(page);
        },

        get paginatedProducts() {
            return this.products;
        },

        get currentPageStart() {
            return (this.currentPage - 1) * this.itemsPerPage + 1;
        },

        get currentPageEnd() {
            return Math.min(this.currentPage * this.itemsPerPage, this.totalItems);
        },
		get pageNumbers() {
            const range = 2; // Number of pages to show around the current page
            let start = Math.max(1, this.currentPage - range);
            let end = Math.min(this.totalPages, this.currentPage + range);

            // Adjust range if there are not enough pages on one side
            if (this.totalPages - end < range) {
                end = this.totalPages;
                start = Math.max(1, end - 2 * range);
            } else if (start <= range) {
                start = 1;
                end = Math.min(this.totalPages, start + 2 * range);
            }
			
            return Array.from({ length: end - start + 1 }, (_, i) => start + i);
        },
		 badgeClass(status) {
				const baseClass = 'badge bg-body-secondary badge-custom'; // Add badge-custom class
				switch (status) {
					case 'pending':
						return `${baseClass} text-warning`;
					case 'completed':
						return `${baseClass} text-success`;
					case 'cancelled':
						return `${baseClass} text-danger`;
					case 'processing':
						return `${baseClass} text-warning`;
					default:
						return baseClass;
				}
		}		
    };
}
</script>
}
